var S = Object.defineProperty;
var w = (t) => S(t, "__esModule", { value: !0 });
var O = (t, e) => {
  w(t);
  for (var n in e)
    S(t, n, { get: e[n], enumerable: !0 });
};

// src/index.ts
O(exports, {
  restoreAll: () => K,
  spies: () => g,
  spy: () => h,
  spyOn: () => b
});

// src/utils.ts
function d(t, e) {
  if (!t)
    throw new Error(e);
}
function u(t, e) {
  return typeof e === t;
}
function f(t, e, n) {
  Object.defineProperty(t, e, n);
}

// src/spy.ts
var g = /* @__PURE__ */ new Set();
function h(t) {
  d(u("function", t) || u("undefined", t), "cannot spy on a non-function value");
  let e = function(...i) {
    if (e.called = !0, e.callCount++, e.calls.push(i), e.next) {
      let [o, l] = e.next;
      if (e.results.push(e.next), e.next = null, o === "ok")
        return l;
      throw l;
    }
    let r, s = "ok";
    if (e.impl)
      try {
        r = e.impl.apply(this, i), s = "ok";
      } catch (o) {
        throw r = o, s = "error", e.results.push([s, o]), o;
      }
    let c = [s, r];
    if (r && u("object", r) && u("function", r.then)) {
      let o = r.then((l) => c[1] = l).catch((l) => {
        throw c[0] = "error", c[1] = l, l;
      });
      Object.assign(o, r), r = o;
    }
    return e.results.push(c), r;
  };
  f(e, "_isMockFunction", { get: () => !0 }), f(e, "length", { value: t ? t.length : 0 }), f(e, "returns", {
    get() {
      return this.results.map(([, i]) => i);
    }
  }), f(e, "name", { value: t && t.name || "spy" });
  let n = () => {
    e.called = !1, e.callCount = 0, e.results = [], e.calls = [];
  };
  return n(), e.impl = t, e.reset = n, e.nextError = (i) => (e.next = ["error", i], e), e.nextResult = (i) => (e.next = ["ok", i], e), e;
}

// src/spyOn.ts
var v = (t, e) => Object.getOwnPropertyDescriptor(t, e);
function b(t, e, n) {
  d(!u("undefined", t), "spyOn could not find an object to spy upon"), d(u("object", t) || u("function", t), "cannot spyOn on a primitive value");
  let i = () => {
    if (typeof e != "object")
      return [e, "value"];
    if ("getter" in e && "setter" in e)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in e)
      return [e.getter, "get"];
    if ("setter" in e)
      return [e.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  }, [r, s] = i(), c = v(t, r), o = Object.getPrototypeOf(t), l = o && v(o, r), a = c || l;
  d(a || r in t, `${String(r)} does not exist`);
  let R = !1;
  s === "value" && a && !a.value && a.get && (s = "get", R = !0, n = a.get());
  let y;
  a ? y = a[s] : s !== "value" ? y = () => t[r] : y = t[r], n || (n = y);
  let p = h(n), A = (T) => {
    let { value: P, ...m } = a || {
      configurable: !0,
      writable: !0
    };
    s !== "value" && delete m.writable, m[s] = T, f(t, r, m);
  }, k = () => A(y);
  return p.restore = k, p.getOriginal = () => R ? y() : y, p.willCall = (T) => (p.impl = T, p), A(R ? () => p : p), g.add(p), p;
}

// src/restoreAll.ts
function K() {
  for (let t of g)
    t.restore();
  g.clear();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  restoreAll,
  spies,
  spy,
  spyOn
});
